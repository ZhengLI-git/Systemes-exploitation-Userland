/*
 * Auteur(s):Zheng LI
 *
 * Le programme utilise plusieurs threads pour calculer la valeur de PI et le nombre de threads 
 * peut être modifié en changeant thread_count. En comparant le temps de sortie des résultats, il 
 * est conclu que plus il y a de threads, plus le temps de calcul est court.
 *
 * Utilisation de pthread.
 */

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/time.h>

pthread_mutex_t mutexsum;//mutex
#define thread_count   50
double sum;//chacun de ces threads ajoutera son résultat à la variable globale sum


void* start_thread(void *rank)
{
    long my_rank = rank;
    double factor;
    long long i ;
    long long my_n = 80000000/thread_count ;
    long long my_first_i = my_n*my_rank;
    long long my_last_i = my_first_i + my_n;
    double my_sum = 0.0;
    //estimation de π/4
    if(my_first_i % 2 == 0)
        factor = 1.0;
    else
        factor = -1.0;

    for(i = my_first_i;i<my_last_i;i++,factor = -factor)
    {
        my_sum += factor / (2*i+1);
    }

    pthread_mutex_lock (&mutexsum);
    sum  += my_sum;
    pthread_mutex_unlock (&mutexsum);
    return NULL;
}


int main(void)
{
    long thread;
    pthread_t thread_handles[thread_count];
    //thread_handles = malloc(thread_count*sizeof(pthread_t));

    struct timeval tpstart,tpend;//Pour comparer le temps
    float timeuse;
    gettimeofday(&tpstart,NULL);//Extraire l'heure système

    pthread_mutex_init(&mutexsum, NULL);

    for(thread=0;thread<thread_count;thread++)
    {
        /* Chaque thread fonctionne sur un ensemble de données différent.
         * Le décalage est spécifié par 'i'. La taille de
         * les données de chaque thread sont indiquées par VECLEN.
         */
        pthread_create(&thread_handles[thread], NULL, start_thread, (void *)thread); //Créer un thread
    }
    
    //Attendez sur les autres threads
    for(thread=0;thread<thread_count;thread++) 
    {
        pthread_join(thread_handles[thread], NULL);//Le thread principal attendra que le thread en attente se termine lui-même, afin que le thread créé ait une chance de s'exécuter.
    }
    gettimeofday(&tpend,NULL);//Extraire l'heure système
    timeuse=1000000*(tpend.tv_sec-tpstart.tv_sec)+tpend.tv_usec-tpstart.tv_usec;
    timeuse/=1000000;
    
    printf("sum  is:%lf,and run time is: %fs \n",4*sum,timeuse);

    pthread_mutex_destroy(&mutexsum);//Libérez les ressources occupées par le mutex
    pthread_exit(NULL);

    return 0;
}
