#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define BUFSIZE 512
int ns;
void sig_urg(int something)
{
    int r;
    char buf[BUFSIZE];
    r = recv(ns, buf, BUFSIZE, MSG_OOB);
    if (r > 0) {
        buf[r] = 0;
        printf("recv data：%s\n", buf);
    }
}

int main(int argc, char** argv)
{
    

    int sfd, s, r;
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    char buf[BUFSIZE];
    ssize_t nread, nwrite;
    struct sockaddr_storage from;
    socklen_t fromlen;
    char host[NI_MAXHOST];
    char* message = "Message a envoyer: ";

    if (argc != 2) {
        printf("Usage: %s  port_serveur\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    /* Construction de l'adresse locale (pour bind) */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET6; /* Force IPv6 */
    hints.ai_socktype = SOCK_STREAM; /* Stream socket */
    hints.ai_flags = AI_PASSIVE; /* Adresse IP joker */
    hints.ai_flags |= AI_V4MAPPED | AI_ALL; /* IPv4 remapped en IPv6 */
    hints.ai_protocol = 0; /* Any protocol */

    s = getaddrinfo(NULL, argv[1], &hints, &result);
    if (s != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
        exit(EXIT_FAILURE);
    }

    /* getaddrinfo() retourne une liste de structures d'adresses.
     On essaie chaque adresse jusqu'a ce que bind(2) reussisse.
     Si socket(2) (ou bind(2)) echoue, on (ferme la socket et on)
     essaie l'adresse suivante. cf man getaddrinfo(3) */
    for (rp = result; rp != NULL; rp = rp->ai_next) {

        /* Creation de la socket */
        //sfd = ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
        sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (sfd == -1)
            continue;

        /* Association d'un port a la socket */
        r = bind(sfd, rp->ai_addr, rp->ai_addrlen);
        // r = ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
        if (r == 0)
            break; /* Succes */
        close(sfd);
    }

    //fcntl (sfd, F_SETOWN, getpid());

    if (rp == NULL) { /* Aucune adresse valide */
        perror("bind");
        exit(EXIT_FAILURE);
    }
    freeaddrinfo(result); /* Plus besoin */

    /* Positionnement de la machine a etats TCP sur listen */
    listen(sfd, SOMAXCONN);
    //? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
    
    for (;;) {
        /* Acceptation de connexions */
        fromlen = sizeof(from);
        // ns = ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
        ns = accept(sfd, (struct sockaddr*)&from, &fromlen);
        if (ns == -1) {
            perror("accept");
            exit(EXIT_FAILURE);
        }

        /* Reconnaissance de la machine cliente */
        s = getnameinfo((struct sockaddr*)&from, fromlen,
            host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
        if (s == 0)
            printf("Debut avec client '%s'\n", host);
        else
            fprintf(stderr, "getnameinfo: %s\n", gai_strerror(s));
        
        fcntl(ns,F_SETOWN,getpid());    //Créez le processus en tant que propriétaire du socket afin que lorsque des données hors bande arrivent, le noyau envoie un signal SIGURG au processus
        signal(SIGURG, sig_urg);
        for (;;) {
            nwrite = write(ns, message, strlen(message));
            if (nwrite < 0) {
                perror("write");
                close(ns);
                break;
            }
            nread = recv(ns, buf, BUFSIZE, 0);
            if (nread == 0) {
                printf("Fin avec client '%s'\n", host);
                close(ns);
                break;
            } else if (nread < 0) {
                perror("read");
                close(ns);
                break;
            }
            buf[nread] = '\0';
            printf("Message recu '%s'\n", buf);
        }
    }
}
