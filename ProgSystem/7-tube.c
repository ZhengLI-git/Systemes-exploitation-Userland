/* 
 * Auteur(s):Zheng LI
 *Ce programme établit un canal unidirectionnel anonyme, le processus parent écrit à partir du 
 *clavier et le processus enfant lit. Une fois le programme exécuté, entrez la chaîne à partir du 
 *clavier.
 * 
*/


#include <stdio.h>                                  
#include <stdlib.h>                                 
#include <string.h>                                 
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h> 

int main(int argc, char **argv)
{
	int fd[2];
	char buf[100];
	//char bufferA[BUFSIZ + 1];
	//char bufferB[BUFSIZ + 1];
	if(pipe(fd))//Create a pipeline
    {
		printf("err");
		return EXIT_FAILURE;
	}

	switch(fork()) //Create process
	{
		case -1:
			printf("err");
			return EXIT_FAILURE;
		
		case 0:
			//close(fd[1]);
			//dup2(fd[0], STDIN_FILENO );
			//close(fd[0]);
	
			//fprintf(stderr, "fooA");
			//read(fd[0], bufferA, BUFSIZ);
			//fprintf(stderr, "fooB");
			//fprintf(stderr, "(child)%s\n", bufferA);
			printf("this is in the child process,read a string from the pipe...\n");
			read(fd[0],buf,sizeof(buf)); //get the message
			printf("read : %s\n",buf);
			sleep(1);
			close(fd[0]);//The child process closes the read end
			close(fd[1]);
			break;
		
		default:
			//close(fd[0]);
			//close(STDOUT_FILENO);
			//dup2(STDOUT_FILENO,fd[1]);
		
			//fprintf(stderr, "testA");
			//scanf("%s", bufferB);
			//fprintf(stderr, "testB");
			//printf("(parent)");
			//write(fd[1], bufferB, strlen(bufferB));
			//fprintf(stderr, "testC");
			//wait(NULL);
			printf("this is in the father process,write a string to the pipe...\n");
			char str[100] ;
			scanf("%s",str);
			write(fd[1],str,sizeof(str));
			sleep(1);//Sleep for 2 seconds, mainly to wait for the child process to end first
			close(fd[0]);
			close(fd[1]);//The parent process closes the write side
			break; 
	}
	
	return EXIT_SUCCESS;
}

